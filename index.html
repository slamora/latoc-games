<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Circular Simon - Tactical Edition</title>
  <style>
    body {
      margin: 0;
      background-color: #222;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
      font-family: sans-serif;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>

<body>
  <script>
    const config = {
      type: Phaser.AUTO,
      width: 800,
      height: 800,
      backgroundColor: '#333333',
      physics: { default: 'arcade', arcade: { debug: false } },
      scene: { preload: preload, create: create, update: update }
    };

    let game = new Phaser.Game(config);
    let arenaCenter = { x: 400, y: 400 }, arenaRadius = 200, isGameOver = false;
    let winText, restartText; // Variables to hold UI elements for cleanup

    let player1 = {
      name: "P1", color: 0x00ffff,
      angle: Math.PI * 1,
      angVel: 0, angAccel: 0.0006, friction: 0.96, maxSpeed: 0.05,
      health: 3, maxHealth: 3,
      aimAngle: Math.PI * 0,
      laserGfx: null
    };

    let player2 = {
      name: "P2", color: 0xff00ff,
      angle: Math.PI * 0,
      angVel: 0, angAccel: 0.0006, friction: 0.96, maxSpeed: 0.05,
      health: 3, maxHealth: 3,
      aimAngle: Math.PI * 1,
      laserGfx: null
    };

    function preload() {
      let graphics = this.make.graphics();
      const drawTankIcon = (gfx, color) => {
        gfx.clear();
        gfx.fillStyle(color);
        gfx.fillRect(5, 10, 20, 20);
        gfx.fillRect(12, 0, 6, 12);
      };
      drawTankIcon(graphics, player1.color);
      graphics.generateTexture('p1', 30, 30);
      drawTankIcon(graphics, player2.color);
      graphics.generateTexture('p2', 30, 30);
      graphics.clear().fillStyle(0xffffff).fillCircle(5, 5, 5).generateTexture('bullet', 10, 10);
      graphics.destroy();
    }

    function create() {
      this.add.graphics().lineStyle(4, 0x555555).strokeCircle(arenaCenter.x, arenaCenter.y, arenaRadius);

      player1.sprite = this.physics.add.sprite(0, 0, 'p1');
      player2.sprite = this.physics.add.sprite(0, 0, 'p2');
      player1.laserGfx = this.add.graphics();
      player2.laserGfx = this.add.graphics();

      player1.bullets = this.physics.add.group({ maxSize: 2 });
      player2.bullets = this.physics.add.group({ maxSize: 2 });

      player1.healthBar = createHealthBar(this, 50, 50, player1.color);
      player2.healthBar = createHealthBar(this, 550, 50, player2.color);

      this.add.text(50, 15, "P1: A-D (Move) | W-S (Aim) | SPACE (Shoot)", { fontSize: '11px', fill: '#00ffff' });
      this.add.text(480, 15, "P2: ←→ (Move) | ↑↓ (Aim) | ENTER (Shoot)", { fontSize: '11px', fill: '#ff00ff' });

      player1.keys = this.input.keyboard.addKeys({ left: 'A', right: 'D', up: 'W', down: 'S', fire: 'SPACE' });
      player2.keys = this.input.keyboard.addKeys({ left: 'LEFT', right: 'RIGHT', up: 'UP', down: 'DOWN', fire: 'ENTER' });

      this.input.keyboard.on('keydown-SPACE', () => { if (!isGameOver) fire(this, player1); });
      this.input.keyboard.on('keydown-ENTER', () => { if (!isGameOver) fire(this, player2); });

      // Listener for Restart Key
      this.input.keyboard.on('keydown-N', () => { if (isGameOver) resetGame(this); });

      this.physics.add.overlap(player2.sprite, player1.bullets, (p, b) => hit(this, player2, b));
      this.physics.add.overlap(player1.sprite, player2.bullets, (p, b) => hit(this, player1, b));
    }

    function update() {
      if (isGameOver) return;
      updatePlayer(player1);
      updatePlayer(player2);

      [player1.bullets, player2.bullets].forEach(group => {
        group.children.iterate(bullet => {
          if (bullet && bullet.active && Phaser.Math.Distance.Between(arenaCenter.x, arenaCenter.y, bullet.x, bullet.y) > arenaRadius + 150) {
            bullet.setActive(false).setVisible(false);
          }
        });
      });
    }

    function updatePlayer(p) {
      if (p.keys.left.isDown) p.angVel -= p.angAccel;
      else if (p.keys.right.isDown) p.angVel += p.angAccel;
      p.angVel *= p.friction;
      p.angVel = Phaser.Math.Clamp(p.angVel, -p.maxSpeed, p.maxSpeed);
      p.angle += p.angVel;
      p.sprite.setPosition(arenaCenter.x + arenaRadius * Math.cos(p.angle), arenaCenter.y + arenaRadius * Math.sin(p.angle));

      if (p.keys.up.isDown) p.aimAngle -= 0.04;
      if (p.keys.down.isDown) p.aimAngle += 0.04;
      p.sprite.setRotation(p.aimAngle + Math.PI / 2);

      p.laserGfx.clear().lineStyle(1, p.color, 0.4);
      let laserLength = arenaRadius / 5;
      let lx = p.sprite.x + Math.cos(p.aimAngle) * laserLength;
      let ly = p.sprite.y + Math.sin(p.aimAngle) * laserLength;
      p.laserGfx.lineBetween(p.sprite.x, p.sprite.y, lx, ly);
    }

    function fire(scene, p) {
      let bullet = p.bullets.get();
      if (bullet) {
        bullet.setActive(true).setVisible(true).setTexture('bullet').setPosition(p.sprite.x, p.sprite.y);
        scene.physics.velocityFromRotation(p.aimAngle, 500, bullet.body.velocity);
      }
    }

    function createHealthBar(scene, x, y, color) {
      scene.add.graphics().fillStyle(0x555555).fillRect(x, y, 200, 20);
      let barGraphics = scene.add.graphics();
      let barObj = { bar: barGraphics, x: x, y: y, color: color };
      updateHealthBarVisual(barObj, 1);
      return barObj;
    }

    function updateHealthBarVisual(barObj, pct) {
      barObj.bar.clear().fillStyle(barObj.color).fillRect(barObj.x, barObj.y, 200 * Math.max(0, pct), 20);
    }

    function hit(scene, player, bullet) {
      if (!bullet.active) return;
      bullet.setActive(false).setVisible(false).body.stop();
      player.health--;
      updateHealthBarVisual(player.healthBar, player.health / player.maxHealth);
      scene.tweens.add({ targets: player.sprite, alpha: 0, duration: 50, yoyo: true, repeat: 3 });

      if (player.health <= 0) {
        isGameOver = true;
        let winnerName = player.name === 'P1' ? 'PLAYER 2' : 'PLAYER 1';

        winText = scene.add.text(400, 380, `${winnerName} WINS!`, {
          fontSize: '40px', color: '#fff', backgroundColor: '#000', padding: { x: 20, y: 10 }
        }).setOrigin(0.5);

        restartText = scene.add.text(400, 450, `Press 'N' or CLICK HERE to Restart`, {
          fontSize: '20px', color: '#0f0', backgroundColor: '#222', padding: { x: 10, y: 5 }
        }).setOrigin(0.5).setInteractive({ useHandCursor: true });

        restartText.on('pointerdown', () => resetGame(scene));
      }
    }

    function resetGame(scene) {
      // 1. Reset Game State
      isGameOver = false;

      // 2. Clear UI Elements
      if (winText) winText.destroy();
      if (restartText) restartText.destroy();

      // 3. Reset Players
      [player1, player2].forEach((p, index) => {
        p.health = p.maxHealth;
        p.angVel = 0;
        p.angle = (index === 0) ? Math.PI : 0; // P1 Left, P2 Right
        p.aimAngle = (index === 0) ? 0 : Math.PI; // P1 aims right, P2 aims left
        p.sprite.setAlpha(1);
        p.bullets.clear(true, true);
        updateHealthBarVisual(p.healthBar, 1);
      });
    }
  </script>
</body>

</html>
